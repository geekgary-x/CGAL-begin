#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Point_set_3.h>
#include <CGAL/Point_set_3/IO.h>
#include <CGAL/Surface_mesh.h>

#include <CGAL/remove_outliers.h>
#include <CGAL/compute_average_spacing.h>
#include <CGAL/grid_simplify_point_set.h>
#include <CGAL/jet_smooth_point_set.h>
#include <CGAL/jet_estimate_normals.h>
#include <CGAL/mst_orient_normals.h>

#include <CGAL/poisson_surface_reconstruction.h>
#include <CGAL/Advancing_front_surface_reconstruction.h>
#include <CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h>
#include <array>
#include <vector>

typedef CGAL::Exact_predicates_inexact_constructions_kernel Kernel;
typedef Kernel::Point_3 Point_3;
typedef Kernel::Vector_3 Vector_3;
typedef CGAL::Point_set_3<Point_3, Vector_3> Point_set;


int surface_reconstruction()
{
	// 输入点云
	Point_set points;

	std::string fname = CGAL::data_file_path("points_3/building.ply");

	std::ifstream stream(fname, std::ios::binary);

	if (!stream)
	{
		std::cerr << "Error: cannot read file " << fname << std::endl;
		return EXIT_FAILURE;
	}

	stream >> points;

	std::cout << "Read " << points.size() << " point(s)" << std::endl;
	if (points.empty())
		return EXIT_FAILURE;

	// 过滤离平面较为离散的点云
	typename Point_set::iterator rout_it = CGAL::remove_outliers<CGAL::Sequential_tag>(
		points, 24, points.parameters().threshold_percent(5.0)
		);
	points.remove(rout_it, points.end());

	std::cout << points.number_of_removed_points() << " point(s) are outliters" << std::endl;

	// 删除标记为remove的点云内存
	points.collect_garbage();
	std::ofstream out_points_remove_outliers("D:/MeshProcess/outputs/points_remove_outliers.ply", std::ios_base::binary);
	out_points_remove_outliers << points;
	out_points_remove_outliers.close();

	// 计算点云与周围六个顶点的平均距离
	double spacing = CGAL::compute_average_spacing<CGAL::Sequential_tag>(
		points, 6
		);
	// 简化点云
	typename Point_set::iterator gsim_it = CGAL::grid_simplify_point_set(points, 2. * spacing);
	points.remove(gsim_it, points.end());
	std::cout << points.number_of_removed_points()
		<< " point(s) removed after simplification." << std::endl;
	points.collect_garbage();

	CGAL::jet_smooth_point_set<CGAL::Sequential_tag>(points, 24);
	std::ofstream out_points_smooth("D:/MeshProcess/outputs/points_smooth.ply", std::ios_base::binary);
	out_points_smooth << points;
	out_points_smooth.close();

	// Poisson重建
	{
		std::cout << "Begin Poisson reconstructing" << std::endl;
		CGAL::jet_estimate_normals<CGAL::Sequential_tag>(points, 24);
		typename Point_set::iterator unoriented_points_begin =
			CGAL::mst_orient_normals(points, 24); // Use 24 neighbors
		points.remove(unoriented_points_begin, points.end());
		CGAL::Surface_mesh<Point_3> output_mesh;
		CGAL::poisson_surface_reconstruction_delaunay(points.begin(), points.end(), points.point_map(), points.normal_map(), output_mesh, spacing);
		std::ofstream f("D:/MeshProcess/outputs/out_poisson.ply", std::ios_base::binary);
		CGAL::IO::set_binary_mode(f);
		CGAL::IO::write_PLY(f, output_mesh);
		f.close();
		std::cout << "End Poisson reconstructing" << std::endl;
	}

	// Advancing front 重建
	{
		std::cout << "Begin Advancing front reconstructing" << std::endl;
		typedef std::array<std::size_t, 3> Facet; // 三角面索引
		std::vector<Facet> facets;
		CGAL::advancing_front_surface_reconstruction(points.points().begin(), points.points().end(), std::back_inserter(facets));
		std::cout << facets.size()
			<< " facet(s) generated by reconstruction." << std::endl;

		std::vector<Point_3> vertices;
		vertices.reserve(points.size());
		std::copy(points.points().begin(), points.points().end(), std::back_inserter(vertices));
		CGAL::Surface_mesh<Point_3> output_mesh;
		CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh(vertices, facets, output_mesh);
		std::ofstream f("D:/MeshProcess/outputs/out_advancing_front.ply", std::ios_base::binary);
		CGAL::IO::set_binary_mode(f);
		CGAL::IO::write_PLY(f, output_mesh);
		f.close();
		std::cout << "End Advancing front reconstructing" << std::endl;
	}
}
